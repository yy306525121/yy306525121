<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java线程的几种状态与线程的正确停止方式</title>
    <url>/article/1022339597/</url>
    <content><![CDATA[<p>介绍Java线程</p><a id="more"></a><p>我们先看 <code>java.lang.Thread.State</code> 中定义的六种状态：<code>NEW</code>、<code>RUNNABLE</code>、<code>BLOCKED</code>、<code>WAITING</code>、<code>TIMED_WAITING</code>、<code>TERMINATED</code></p><ul><li>New：尚未启动的线程的线程状态</li><li>Runnable：可运行线程的线程状态，等待CPU调度。</li><li>Block：线程阻塞等待监视器锁定的线程状态。处于synchronized同步代码块或方法中被阻塞。</li><li>Waiting：等待线程的线程状态。例如下列不带超时的方式：<code>Object.wait</code>、<code>Thread.join</code>、<code>LockSupport.park</code></li><li>Timed Waiting：具有指定等待时间的等待线程的线程状态。例如下列带超时的方式：<code>Thread.sleep</code>、<code>Object.wait</code>、<code>Thread.join</code>、<code>LockSupport.parkNanos</code>、<code>LockSupport.parkUntil</code></li><li>Terminated：终止线程的线程状态，线程正常完成执行或者出现异常。</li></ul><p><img data-src="/images/%E5%85%AD%E7%A7%8D%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E5%88%87%E6%8D%A2%E5%85%B3%E7%B3%BB.png" alt="六种线程状态的切换示意图"></p><p>注意：线程切换为Terminated状态之后将无法再次进入Runnable状态</p><h1 id="线程的错误停止方式"><a href="#线程的错误停止方式" class="headerlink" title="线程的错误停止方式"></a>线程的错误停止方式</h1><p>首先我们看线程的不正确停止方式：<code>Thread.stop</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		StopThread stopThread = <span class="keyword">new</span> StopThread();</span><br><span class="line">		stopThread.start();</span><br><span class="line">		<span class="comment">//休眠一秒， 确保i变量自增完成</span></span><br><span class="line">		Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">		<span class="comment">//中止线程</span></span><br><span class="line">		stopThread.stop();</span><br><span class="line">		<span class="keyword">while</span> (stopThread.isAlive()) &#123;</span><br><span class="line">			<span class="comment">// 确保线程已经停止</span></span><br><span class="line">		&#125;</span><br><span class="line">		stopThread.print();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StopThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">			<span class="comment">// 增加同步锁， 确保线程安全</span></span><br><span class="line">			++i;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">//休眠10秒，模拟耗时操作</span></span><br><span class="line">				Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			++j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 打印i和j</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"i="</span> + i + <span class="string">" j="</span> + j);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们理想输出为i=1,j=1; 然而实际输出为i=1,j=0；没有保证同步代码块中数据的一致性，破坏了线程安全。</p><h1 id="线程的正确停止方式"><a href="#线程的正确停止方式" class="headerlink" title="线程的正确停止方式"></a>线程的正确停止方式</h1><h2 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h2><p>接下来我们看一下线程的正确停止方式 <code>interrupt</code><br>调用interrupt时，如果目标线程Object的wait()、wait(long)或wait(long,int)方法、join()、join(long, int)、sleep(long, int)或sleep(long, int)方法时被阻塞。那么interrupt会生效，该线程的中断状态会被清除，抛出interruptException异常。</p><p>如果目标线程是被IO或者NIO中的channel所阻塞，同样，IO操作会被中断或者返回特殊异常值。达到终止线程的目的。</p><p>如果以上条件都不满足，则会设置此线程的终端状态。</p><p>将之前的代码中的stop换成interrupt之后再运行，输出如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">	at java.lang.Thread.sleep(Native Method)</span><br><span class="line">	at cn.codeyang.java.StopThread.run(Demo01.java:29)</span><br><span class="line">i&#x3D;1 j&#x3D;1</span><br></pre></td></tr></table></figure><h2 id="设置标志位"><a href="#设置标志位" class="headerlink" title="设置标志位"></a>设置标志位</h2><p>可以在代码逻辑中增加一个判断，用来控制线程执行的终止。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">while</span> (flag) &#123; <span class="comment">//判断是否继续运行</span></span><br><span class="line">					System.out.println(<span class="string">"运行中"</span>);</span><br><span class="line">					Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//3秒后，将状态标志位改为false,代表不继续运行</span></span><br><span class="line">		Thread.sleep(<span class="number">3000L</span>);</span><br><span class="line">		flag = <span class="keyword">false</span>;</span><br><span class="line">		System.out.println(<span class="string">"程序运行结束"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Event在项目中的应用</title>
    <url>/article/1266803346/</url>
    <content><![CDATA[<p>介绍Spring Event在项目中的应用</p><a id="more"></a><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>Spring事件通知有几种角色分别为 <code>事件（Event)</code>、<code>监听者（Listener）</code>、<code>通知者（Publisher)</code></p><p>Spring事件监听本身是一种观察者模式，多个监听者去对事件进行观察，当通知者发出通知时每个监听者会做出不同的动作。</p><p>这里我们模拟一个监视黑名单的场景，当发邮件时遇到黑名单中的右键的时候触发事件</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="定义事件"><a href="#定义事件" class="headerlink" title="定义事件"></a>定义事件</h2><p>我们定义一个黑名单事件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationEvent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlackListEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 邮件地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 邮件内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String content;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">BlackListEvent</span><span class="params">(Object source, String address, String content)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(source);</span><br><span class="line">		<span class="keyword">this</span>.address = address;</span><br><span class="line">		<span class="keyword">this</span>.content = content;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> address;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> content;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义管理员监听器"><a href="#定义管理员监听器" class="headerlink" title="定义管理员监听器"></a>定义管理员监听器</h2><p>这里我们定义一个监听器监听黑名单事件，当黑名单事件触发时我们通知管理员。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlackListAdminNotifier</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">BlackListEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(BlackListEvent blackListEvent)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"拦截到黑名单: "</span>+ blackListEvent.getAddress() +<span class="string">", 开始通知管理员..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义客户端"><a href="#定义客户端" class="headerlink" title="定义客户端"></a>定义客户端</h2><p>这里我们定义发送邮件的客户端，当邮件接收者存在黑名单中时触发黑名单事件，这时监听器将收到通知，开始通知管理员。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationEventPublisher;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationEventPublisherAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailService</span> <span class="keyword">implements</span> <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> List&lt;String&gt; blackList;</span><br><span class="line">	<span class="keyword">private</span> ApplicationEventPublisher applicationEventPublisher;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationEventPublisher</span><span class="params">(ApplicationEventPublisher applicationEventPublisher)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.applicationEventPublisher = applicationEventPublisher;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBlackList</span><span class="params">(List&lt;String&gt; blackList)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.blackList = blackList;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">(String address, String content)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (blackList.contains(address)) &#123;</span><br><span class="line">            <span class="comment">//开始通知黑名单事件，所有实现了BlackEvent类型的ApplicationListener都将收到通知，并同步进行处理</span></span><br><span class="line">			applicationEventPublisher.publishEvent(<span class="keyword">new</span> BlackListEvent(<span class="keyword">this</span>, address, content));</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"邮件已发出"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>接下来让我们编写一个测试类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.codeyang.notify.event.EmailService;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">EmailServiceTest</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> EmailService emailService;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span></span>&#123;</span><br><span class="line">		List&lt;String&gt; blackList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		blackList.add(<span class="string">"known.spammer@example.org"</span>);</span><br><span class="line">		blackList.add(<span class="string">"known.hacker@example.org"</span>);</span><br><span class="line">		blackList.add(<span class="string">"john.doe@example.org"</span>);</span><br><span class="line">		emailService.setBlackList(blackList);</span><br><span class="line">        </span><br><span class="line">		emailService.sendEmail(<span class="string">"john.doe@example.org"</span>, <span class="string">"i love you "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OUTPUT:<br><code>拦截到黑名单john.doe@example.org， 开始通知管理员...</code></p><h1 id="定义报警监听器"><a href="#定义报警监听器" class="headerlink" title="定义报警监听器"></a>定义报警监听器</h1><p>当我们想要在触发黑名单并通知管理员的同时去实现报警功能怎么办？<br>这时候我们可以再定义一个报警监听器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlackListPolicyListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">BlackListEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(BlackListEvent event)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"拦截到黑名单： "</span> + event.getAddress() + <span class="string">"，开始报警..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行测试类会出现如下输出：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">拦截到黑名单john.doe@example.org， 开始通知管理员...</span><br><span class="line">拦截到黑名单： john.doe@example.org，开始报警...</span><br></pre></td></tr></table></figure><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ul><li>多个监听事件将会同步执行，而非异步</li><li>可以通过 <code>@Order</code> 对监听事件的执行顺序进行排序</li></ul>]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot前后端分离项目数据格式化问题</title>
    <url>/article/2531510583/</url>
    <content><![CDATA[<p>SpringBoot前后端分离项目时间格式化问题以及Long转换为字符串的问题</p><a id="more"></a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonConverterConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Date格式化字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DATE_FORMAT = <span class="string">"yyyy-MM-dd"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * DateTime格式化字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DATETIME_FORMAT = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Time格式化字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TIME_FORMAT = <span class="string">"HH:mm:ss"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义Bean</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Jackson2ObjectMapperBuilderCustomizer <span class="title">jackson2ObjectMapperBuilderCustomizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> builder -&gt; builder.serializerByType(LocalDateTime<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">LocalDateTimeSerializer</span>(<span class="title">DateTimeFormatter</span>.<span class="title">ofPattern</span>(<span class="title">DATETIME_FORMAT</span>)))</span></span><br><span class="line"><span class="class">                .<span class="title">serializerByType</span>(<span class="title">LocalDate</span>.<span class="title">class</span>, <span class="title">new</span> <span class="title">LocalDateSerializer</span>(<span class="title">DateTimeFormatter</span>.<span class="title">ofPattern</span>(<span class="title">DATE_FORMAT</span>)))</span></span><br><span class="line"><span class="class">                .<span class="title">serializerByType</span>(<span class="title">LocalTime</span>.<span class="title">class</span>, <span class="title">new</span> <span class="title">LocalTimeSerializer</span>(<span class="title">DateTimeFormatter</span>.<span class="title">ofPattern</span>(<span class="title">TIME_FORMAT</span>)))</span></span><br><span class="line"><span class="class">                .<span class="title">deserializerByType</span>(<span class="title">LocalDateTime</span>.<span class="title">class</span>, <span class="title">new</span> <span class="title">LocalDateTimeDeserializer</span>(<span class="title">DateTimeFormatter</span>.<span class="title">ofPattern</span>(<span class="title">DATETIME_FORMAT</span>)))</span></span><br><span class="line"><span class="class">                .<span class="title">deserializerByType</span>(<span class="title">LocalDate</span>.<span class="title">class</span>, <span class="title">new</span> <span class="title">LocalDateDeserializer</span>(<span class="title">DateTimeFormatter</span>.<span class="title">ofPattern</span>(<span class="title">DATE_FORMAT</span>)))</span></span><br><span class="line"><span class="class">                .<span class="title">deserializerByType</span>(<span class="title">LocalTime</span>.<span class="title">class</span>, <span class="title">new</span> <span class="title">LocalTimeDeserializer</span>(<span class="title">DateTimeFormatter</span>.<span class="title">ofPattern</span>(<span class="title">TIME_FORMAT</span>)))</span></span><br><span class="line"><span class="class">                   // <span class="title">long</span>类型数字传给前端之后变为字符串格式</span></span><br><span class="line"><span class="class">                .<span class="title">serializerByType</span>(<span class="title">Long</span>.<span class="title">class</span>, <span class="title">ToStringSerializer</span>.<span class="title">instance</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>日期格式化</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode(747) 至少是其他数字两倍的最大数</title>
    <url>/article/3438908986/</url>
    <content><![CDATA[<p>这篇文章介绍了怎么查找一个数组中是否存在一个元素至少是其他所有元素的两倍</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>在一个给定的数组nums中，总是存在一个最大元素 。<br>查找数组中的最大元素是否至少是数组中每个其他数字的两倍。<br>如果是，则返回最大元素的索引，否则返回-1。<br>示例 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [3, 6, 1, 0]</span><br><span class="line">输出: 1</span><br><span class="line">解释: 6是最大的整数, 对于数组中的其他整数,</span><br><span class="line">6大于数组中其他元素的两倍。6的索引是1, 所以我们返回1.</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>确保数组中最大元素是其他元素的两倍, 我们只需要找到最大数和第二大数, 并保证最大数至少是第二大数的两倍即可<br>因此我们只需要一次遍历, 找出第一大数和第二大数即可</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ol><li>初始一个相对较小的最大值 <code>x</code> , 第二大值 <code>y</code>, 最大值索引 <code>index = -1</code></li><li>遍历数组并比较最大值和第二大值<ul><li>如果当前值大于最大值就将最大值 <code>x</code> 赋值给第二大值 <code>y</code>, 同时替换最大值 <code>x</code> 并更新 <code>index</code></li><li>如果当前值小于最大值并且大于第二大值, 替换第二大值 <code>y</code></li></ul></li><li>遍历完成之后判断最大值 <code>x</code> 是否大于第二大值 <code>y</code>, 如果是, 返回 <code>index</code> 否则返回 <code>-1</code></li></ol><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dominantIndex</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> second = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; max)&#123;</span><br><span class="line">            second = max;</span><br><span class="line">            max = nums[i];</span><br><span class="line">            index = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &gt; second)&#123;</span><br><span class="line">            second = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (max &gt;= second*<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring解决循环依赖</title>
    <url>/article/4186930119/</url>
    <content><![CDATA[<p>Spring解决循环依赖</p><a id="more"></a><h2 id="构造器循环依赖"><a href="#构造器循环依赖" class="headerlink" title="构造器循环依赖"></a>构造器循环依赖</h2><p>表示通过构造器注入造成的循环依赖问题，此依赖是无法解决的，只能通过抛出BeanCurrentlyCreationException异常。</p><h2 id="setter循环依赖"><a href="#setter循环依赖" class="headerlink" title="setter循环依赖"></a>setter循环依赖</h2><p>Spring可以正常解决此类型的循环依赖。</p><h2 id="prototype类型的循环依赖"><a href="#prototype类型的循环依赖" class="headerlink" title="prototype类型的循环依赖"></a>prototype类型的循环依赖</h2><p>对于prototype类型的循环依赖，Spring容器无法完成循环依赖，因为Spring容器对于prototype类型的bean不会进行缓存，因此无法提前暴露一个正在创建中的bean。</p>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>ip和int之间的相互转换</title>
    <url>/article/2061076427/</url>
    <content><![CDATA[<p>这篇文章介绍了 <code>ip</code> 和 <code>int</code> 之间相互转换的问题</p><a id="more"></a><h2 id="ip转int"><a href="#ip转int" class="headerlink" title="ip转int"></a>ip转int</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>大家都知道计算机中ip以类似<code>192.168.1.1</code> 的格式, 其中包含4个数字每个数字最大为255<br>而<code>Java</code>中<code>byte</code>占1字节,正好可以表达255以内的数字,而我们都知道<code>Java</code>中<code>int</code>占4个字节正好可以存下一个ip</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img data-src="/images/ip_to_int.png" alt="ip转换为int的原理"></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ipToInt</span><span class="params">(String ip)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] ipInt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">int</span> position1 = ip.indexOf(<span class="string">"."</span>);</span><br><span class="line">	<span class="keyword">int</span> position2 = ip.indexOf(<span class="string">"."</span>, position1 + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> position3 = ip.indexOf(<span class="string">"."</span>, position2 + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	ipInt[<span class="number">0</span>] = Integer.parseInt(ip.substring(<span class="number">0</span>, position1));</span><br><span class="line">	ipInt[<span class="number">1</span>] = Integer.parseInt(ip.substring(position1 + <span class="number">1</span>, position2));</span><br><span class="line">	ipInt[<span class="number">2</span>] = Integer.parseInt(ip.substring(position2 + <span class="number">1</span>, position3));</span><br><span class="line">	ipInt[<span class="number">3</span>] = Integer.parseInt(ip.substring(position3 + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (ipInt[<span class="number">0</span>] &lt;&lt; <span class="number">24</span>) | (ipInt[<span class="number">1</span>] &lt;&lt; <span class="number">16</span>) | (ipInt[<span class="number">2</span>] &lt;&lt; <span class="number">8</span>) | ipInt[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="int转ip"><a href="#int转ip" class="headerlink" title="int转ip"></a>int转ip</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>通过上面思路我们知道<code>IP</code>转<code>int</code>是通过4个数左移加上或运算得来的<br>相反, 如果我们想把<code>int</code>转成<code>ip</code>通过不停地右移就行了<br>但是, 右移之后我们怎样将他转成10进制呢?<br>比如上面我们得到的<code>1100 0000 1010 1000 0000 0001 0000 0001</code>右移<code>24</code>位之后是<code>1100 0000</code> <code>jvm</code>在将他作为int输出到控制台的时候会做一个补位的操作,因为<code>int</code>是32位所以补位后为<code>1111 1111 1111 1111 1111 1111 1100 0000</code> 计算机对byte类型存储的时候存的是补码, 所以我们 <code>-1</code> 取反之后得到原码 <code>1000 0000 0000 0000 0000 0000 0100 0000</code> 转换位10进制之后得到的是<code>-64</code>, 这不对阿？ 跟我们的192差远了阿?</p><p>这时候我们来看我们所得到的补码<code>1111 1111 1111 1111 1111 1111 1100 0000</code>, 如果我们让前24位变成0， 后四位不变那么岂不是就能得到正确结果了？</p><p>这个时候使用<code>|</code>运算肯定是不现实了, 那我们只能使用<code>&amp;</code>运算了，也就是<br><code>1111 1111 1111 1111 1111 1111 1100 0000</code> &amp;<br><code>0000 0000 0000 0000 0000 0000 1111 1111</code> 我们得到<br><code>0000 0000 0000 0000 0000 0000 1100 0000</code> 转成十进制正好是 192</p><p>bingo 得到正确答案</p><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p><img data-src="/images/int_to_ip.png" alt="int转换为ip的原理"></p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">intToIp</span><span class="params">(<span class="keyword">int</span> ipNum)</span></span>&#123;</span><br><span class="line">	StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">	System.out.println(Integer.toBinaryString(ipNum));</span><br><span class="line">	String ip1 = ((ipNum &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>) + <span class="string">""</span>;</span><br><span class="line">	String ip2 = ((ipNum &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>) + <span class="string">""</span>;</span><br><span class="line">	String ip3 = ((ipNum &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>) + <span class="string">""</span>;</span><br><span class="line">	String ip4 = (ipNum &amp; <span class="number">0xff</span>) + <span class="string">""</span>;</span><br><span class="line">	<span class="keyword">return</span> sb.append(ip1).append(<span class="string">"."</span>).append(ip2).append(<span class="string">"."</span>).append(ip3).append(<span class="string">"."</span>).append(ip4).toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>java sql解析工具 JSqlParser使用</title>
    <url>/article/3816498426/</url>
    <content><![CDATA[<p>JSqlParsers的使用</p><a id="more"></a><h1 id="解析sql"><a href="#解析sql" class="headerlink" title="解析sql"></a>解析sql</h1><h2 id="获取表名"><a href="#获取表名" class="headerlink" title="获取表名"></a>获取表名</h2><h3 id="单表"><a href="#单表" class="headerlink" title="单表"></a>单表</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">String sql = "<span class="keyword">select</span> <span class="keyword">name</span>, age <span class="keyword">from</span> t_user<span class="string">";</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Statement statement = CCJSqlParserUtil.parse(sql);</span></span><br><span class="line"><span class="string">Select select = (Select) statement;</span></span><br><span class="line"><span class="string">PlainSelect plainSelect = (PlainSelect) select.getSelectBody();</span></span><br><span class="line"><span class="string">Table table = (Table) plainSelect.getFromItem();</span></span><br></pre></td></tr></table></figure><h3 id="多表"><a href="#多表" class="headerlink" title="多表"></a>多表</h3><p>只能获取表名:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">String sql = "<span class="keyword">select</span> u.name, u.age, a.code <span class="keyword">from</span> t_user u <span class="keyword">left</span> <span class="keyword">join</span> t_address a <span class="keyword">on</span> a.user_id = u.id<span class="string">";</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Statement statement = CCJSqlParserUtil.parse(sql);</span></span><br><span class="line"><span class="string">Select select = (Select) statement;</span></span><br><span class="line"><span class="string">TablesNamesFinder tablesNamesFinder = new TablesNamesFinder();</span></span><br><span class="line"><span class="string">List&lt;String&gt; tableList = tablesNamesFinder.getTableList(select);</span></span><br><span class="line"><span class="string">for (Iterator iter = tableList.iterator(); iter.hasNext();) &#123;</span></span><br><span class="line"><span class="string">    String tableName = (String) iter.next();</span></span><br><span class="line"><span class="string">    System.out.println(tableName);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>获取表明的同时获取别名信心</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String sql = <span class="string">"select u.name, u.age, a.code from t_user u left join t_address a on a.user_id = u.id"</span>;</span><br><span class="line"></span><br><span class="line">List&lt;Table&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">Statement statement = CCJSqlParserUtil.parse(sql);</span><br><span class="line">Select select = (Select) statement;</span><br><span class="line">PlainSelect plainSelect = (PlainSelect) select.getSelectBody();</span><br><span class="line">Table table = (Table) plainSelect.getFromItem();</span><br><span class="line">list.add(table);</span><br><span class="line"></span><br><span class="line">List&lt;Join&gt; joins = plainSelect.getJoins();</span><br><span class="line">joins.forEach(join -&gt; &#123;</span><br><span class="line">    Table tableJoin = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (join.isRight()) &#123;</span><br><span class="line">        tableJoin = (Table) join.getRightItem();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (join.isLeft() || join.isInner()) &#123;</span><br><span class="line">        tableJoin = (Table) join.getRightItem();</span><br><span class="line">    &#125;</span><br><span class="line">    list.add(tableJoin);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="构建sql"><a href="#构建sql" class="headerlink" title="构建sql"></a>构建sql</h2><h3 id="通过表明和字段构建sql"><a href="#通过表明和字段构建sql" class="headerlink" title="通过表明和字段构建sql"></a>通过表明和字段构建sql</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Select select = SelectUtils.buildSelectFromTableAndExpressions(<span class="keyword">new</span> Table(<span class="string">"mytable"</span>), <span class="keyword">new</span> Column(<span class="string">"a"</span>), <span class="keyword">new</span> Column(<span class="string">"b"</span>));</span><br><span class="line">System.out.println(select.toString());</span><br><span class="line"><span class="comment">// output: SELECT a, b FROM mytable</span></span><br><span class="line"></span><br><span class="line">select = SelectUtils.buildSelectFromTableAndExpressions(<span class="keyword">new</span> Table(<span class="string">"mytable"</span>), <span class="string">"a+b"</span>, <span class="string">"test"</span>);</span><br><span class="line">System.out.println(select.toString());</span><br><span class="line"><span class="comment">// output: SELECT a + b, test FROM mytable</span></span><br></pre></td></tr></table></figure><h3 id="为-select-name-from-user-增加-WHERE-id-1000-条件"><a href="#为-select-name-from-user-增加-WHERE-id-1000-条件" class="headerlink" title="为 select name from user 增加 WHERE id = 1000 条件"></a>为 select name from user 增加 WHERE id = 1000 条件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Select select = (Select) CCJSqlParserUtil.parse(<span class="string">"select name from user"</span>);</span><br><span class="line">PlainSelect plainSelect = (PlainSelect) select.getSelectBody();</span><br><span class="line"><span class="keyword">if</span> (plainSelect.getWhere() == <span class="keyword">null</span>) &#123;</span><br><span class="line">    EqualsTo equalsTo = <span class="keyword">new</span> EqualsTo();</span><br><span class="line">    equalsTo.setLeftExpression(<span class="keyword">new</span> Column(<span class="string">"id"</span>));</span><br><span class="line">    equalsTo.setRightExpression(<span class="keyword">new</span> LongValue(<span class="number">1000L</span>));</span><br><span class="line">    plainSelect.setWhere(equalsTo);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(select.toString());</span><br></pre></td></tr></table></figure><h3 id="为-select-name-from-user-where-id-1000-增加-and-name-‘张三’-的条件"><a href="#为-select-name-from-user-where-id-1000-增加-and-name-‘张三’-的条件" class="headerlink" title="为 select name from user where id = 1000 增加 and name = ‘张三’ 的条件"></a>为 select name from user where id = 1000 增加 and name = ‘张三’ 的条件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Select select = (Select) CCJSqlParserUtil.parse(<span class="string">"select name from user where id = 1000"</span>);</span><br><span class="line">PlainSelect plainSelect = (PlainSelect) select.getSelectBody();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原where表达式</span></span><br><span class="line">Expression where = plainSelect.getWhere();</span><br><span class="line"><span class="comment">// 新增的查询条件表达式</span></span><br><span class="line">EqualsTo equalsTo = <span class="keyword">new</span> EqualsTo();</span><br><span class="line">equalsTo.setLeftExpression(<span class="keyword">new</span> Column(<span class="string">"name"</span>));</span><br><span class="line">equalsTo.setRightExpression(<span class="keyword">new</span> StringValue(<span class="string">"'张三'"</span>));</span><br><span class="line"><span class="comment">// 用and链接条件</span></span><br><span class="line">AndExpression and = <span class="keyword">new</span> AndExpression(where, equalsTo);</span><br><span class="line"><span class="comment">// 设置新的where条件</span></span><br><span class="line">plainSelect.setWhere(and);</span><br><span class="line"></span><br><span class="line">System.out.println(select.toString());</span><br></pre></td></tr></table></figure><h3 id="为-select-name-from-user-u-where-u-id-1000-增加-AND-u-name-IS-NOT-NULL-的条件"><a href="#为-select-name-from-user-u-where-u-id-1000-增加-AND-u-name-IS-NOT-NULL-的条件" class="headerlink" title="为 select name from user u where u.id = 1000 增加  AND u.name IS NOT NULL 的条件"></a>为 select name from user u where u.id = 1000 增加 AND u.name IS NOT NULL 的条件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Select select = (Select) CCJSqlParserUtil.parse(<span class="string">"select name from user u where u.id = 1000"</span>);</span><br><span class="line">PlainSelect plainSelect = (PlainSelect) select.getSelectBody();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原where表达式</span></span><br><span class="line">Expression where = plainSelect.getWhere();</span><br><span class="line">Table table = (Table) plainSelect.getFromItem();</span><br><span class="line"><span class="comment">// 新增的null判断条件</span></span><br><span class="line">IsNullExpression isNullExpression = <span class="keyword">new</span> IsNullExpression();</span><br><span class="line">isNullExpression.setLeftExpression(<span class="keyword">new</span> Column(table, <span class="string">"name"</span>));</span><br><span class="line">isNullExpression.setNot(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 用and链接条件</span></span><br><span class="line">AndExpression and = <span class="keyword">new</span> AndExpression(where, isNullExpression);</span><br><span class="line"><span class="comment">// 设置新的where条件</span></span><br><span class="line">plainSelect.setWhere(and);</span><br><span class="line"></span><br><span class="line">System.out.println(select.toString());</span><br></pre></td></tr></table></figure><h3 id="为sql添加多个and条件"><a href="#为sql添加多个and条件" class="headerlink" title="为sql添加多个and条件"></a>为sql添加多个and条件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Select select = (Select) CCJSqlParserUtil.parse(<span class="string">"select name from user where id = 1000"</span>);</span><br><span class="line">PlainSelect plainSelect = (PlainSelect) select.getSelectBody();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原where表达式</span></span><br><span class="line">Expression where = plainSelect.getWhere();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (where != <span class="keyword">null</span>) &#123;</span><br><span class="line">    EqualsTo equalsTo = <span class="keyword">new</span> EqualsTo();</span><br><span class="line">    equalsTo.setLeftExpression(<span class="keyword">new</span> Column(<span class="string">"name"</span>));</span><br><span class="line">    equalsTo.setRightExpression(<span class="keyword">new</span> StringValue(<span class="string">"张三"</span>));</span><br><span class="line"></span><br><span class="line">    LikeExpression likeExpression = <span class="keyword">new</span> LikeExpression();</span><br><span class="line">    likeExpression.setLeftExpression(<span class="keyword">new</span> Column(<span class="string">"orgCode"</span>));</span><br><span class="line">    likeExpression.setRightExpression(<span class="keyword">new</span> StringValue(<span class="string">"01"</span> + <span class="string">"%"</span>));</span><br><span class="line"></span><br><span class="line">    InExpression inExpression = <span class="keyword">new</span> InExpression();</span><br><span class="line">    inExpression.setLeftExpression(<span class="keyword">new</span> Column(<span class="string">"orgCode"</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ExpressionList expressionList = <span class="keyword">new</span> ExpressionList();</span><br><span class="line">    List&lt;Expression&gt; inList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    inList.add(<span class="keyword">new</span> LongValue(<span class="number">5</span>));</span><br><span class="line">    inList.add(<span class="keyword">new</span> LongValue(<span class="number">6</span>));</span><br><span class="line">    expressionList.setExpressions(inList);</span><br><span class="line"></span><br><span class="line">    inExpression.setRightItemsList(expressionList);</span><br><span class="line">    System.out.println(inExpression.toString());</span><br><span class="line"></span><br><span class="line">    List&lt;Expression&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(equalsTo);</span><br><span class="line">    list.add(likeExpression);</span><br><span class="line">    list.add(where);</span><br><span class="line">    list.add(inExpression);</span><br><span class="line">    MultiAndExpression multiAndExpression = <span class="keyword">new</span> MultiAndExpression(list);</span><br><span class="line"></span><br><span class="line">    plainSelect.setWhere(multiAndExpression);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.println(select.toString());</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java,工具</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm详解(一) - 内存区域详解</title>
    <url>/article/1361420174/</url>
    <content><![CDATA[<p>介绍jvm的主要内存区域</p><a id="more"></a><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p><img data-src="/images/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-jdk1.6.png" alt="运行时数据区"></p><p><img data-src="/images/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-jdk1.8.png" alt="运行时数据区"></p><h2 id="程序计数器-The-pc-Register"><a href="#程序计数器-The-pc-Register" class="headerlink" title="程序计数器(The pc Register)"></a>程序计数器(The pc Register)</h2><p>程序计数器是一块较小的空间, 它可以看作是当前线程所执行的字节码的行号指示器。<br>在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现）字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>从上面的介绍我们知道程序计数器有以下两个作用:</p><ul><li>字节码解释器通过改变程序计数器的值来实现代码的流程控制。</li><li>多线程情况下, 程序计数器可以记录当前线程执行的位置, 从而实现线程切换之后仍能切换回代码执行的位置。</li></ul><p>注意: 程序计数器是唯一一个不会出现 <code>OutOfMemoryError</code> 的区域。</p><h2 id="Java虚拟机栈-Java-Virtual-Machine-Stacks"><a href="#Java虚拟机栈-Java-Virtual-Machine-Stacks" class="headerlink" title="Java虚拟机栈(Java Virtual Machine Stacks)"></a>Java虚拟机栈(Java Virtual Machine Stacks)</h2><p>和程序计数器一样, <code>Java虚拟机栈</code> 也是线程私有的, 它的生命周期与线程相同。<br>虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。<br>每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p><p>Java内存可以粗糙的分为 <code>堆</code> 和 <code>栈</code>, 其中 <code>栈</code> 就是我们这里的虚拟机栈。</p><p>局部变量表存放了编译期可知的各种基础数据类型（boolean、byte、char、short、int、float、double）、对象引用（reference类型）和returnAddress类型（指向了一条字节码指令的地址）。<br>其中64位长度的 <code>long</code> 和 <code>double</code> 类型的数据会占用2个局部变量空间，其余的数据类型只占用1个。</p><p>Java虚拟机栈会出现两种异常</p><ul><li>StackOverflowError: 线程请求栈的深度大于虚拟机所允许的深度。</li><li>OutOfMemoryError: 如果虚拟机栈允许动态扩展, 且扩展时无法申请到足够的内存时，就会抛出OutOfMemoryError。</li></ul><h2 id="本地方法栈-Native-Method-Stacks"><a href="#本地方法栈-Native-Method-Stacks" class="headerlink" title="本地方法栈(Native Method Stacks)"></a>本地方法栈(Native Method Stacks)</h2><p><code>本地方法栈</code> 也叫做C栈，和java虚拟机栈功能类似, 区别是java虚拟机栈执行的是java方法, 而本地方法栈执行的是 <code>native</code> 方法<br>与虚拟机栈一样本地方法栈也会抛出 <code>StackOverflowError</code> 和 <code>OutOfMemoryError</code> 。</p><h2 id="Java堆-Heap"><a href="#Java堆-Heap" class="headerlink" title="Java堆(Heap)"></a>Java堆(Heap)</h2><p><code>Java堆</code> 是一块所有线程共享的内存区域, 也是Java虚拟机所管理的内存中最大的一块, 它随着虚拟机的启动而创建。<br>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</p><p><code>Java堆</code> 是垃圾收集器管理的主要区域，因此很多时候也被称为GC堆。从内存回收的角度来看，由于现在收集器基本都是采用分代收集算法，所以Java堆中还可以细分为：<code>新生代</code> 和 <code>老年代</code> ；再细一点的有 <code>Eden空间</code>、 <code>From Survivor空间</code>、<code>To Survivor空间</code> 等。</p><p>如果在堆中没有内存完成实例分配，并且堆也无法进行扩展时，将会抛出 <code>OutOfMemoryError</code> 异常。</p><h2 id="方法区-Method-Area"><a href="#方法区-Method-Area" class="headerlink" title="方法区(Method Area)"></a>方法区(Method Area)</h2><p><code>方法区</code> 与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。<br>虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Head(非堆)，目的应该是与Java堆区分开来。</p><p>对于习惯在HotSpot虚拟机上开发、部署程序的开发者来说，很多人更愿意把方法区称为永久代，其实本质上两者并不等价。HotSpot虚拟机只是使用永久代来实现方法区而已，永久代也只是HotSpot虚拟机的叫法， 对于其他虚拟机来说是不存在永久代的概念的。</p><p>在JDK1.8中方法区已经被 <code>元空间（Meatspace）</code> 所取代</p><h2 id="运行时常量池-Run-Time-Constant-Pool"><a href="#运行时常量池-Run-Time-Constant-Pool" class="headerlink" title="运行时常量池(Run-Time Constant Pool)"></a>运行时常量池(Run-Time Constant Pool)</h2><p><code>运行时常量池</code> 是方法区的一部分。 Class文件中除了有类的版本、字段、方法、接口等描述信息之外，还有常量池信息（用于存放编译期产生的各种字面量和符号引用）这部分内容将在类加载后进入方法区的运行时常量池中存放。</p><p>既然 <code>运行时常量池</code> 是方法区的一部分，自然受到方法区内存的限制，当无法申请到足够的内存时将抛出 <code>OutOfMemoryError</code>。</p><p>JDK1.7 及以后的jvm将运行时常量池从方法区移到了Java堆中。</p><h2 id="直接内存（Direct-Memory）"><a href="#直接内存（Direct-Memory）" class="headerlink" title="直接内存（Direct Memory）"></a>直接内存（Direct Memory）</h2><p><code>直接内存</code> 并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁的使用，而且也可能导致 <code>OutOfMemoryError</code> 异常出现。</p><p>在JDK1.4中新加入了NIO（New Input/Output)类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p><p>本机直接内存的分配不会受到Java堆大小的限制，但是既然是内存，肯定还是会受到本机总内存大小和处理器寻址空间的限制。服务器管理员在配置虚拟机参数时，会根据实际内存设置 <code>-Xmx</code> 等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制，从而导致动态扩展时出现 <code>OutOfMemoryError</code> 异常。</p><h2 id="字符串相关内容补充"><a href="#字符串相关内容补充" class="headerlink" title="字符串相关内容补充"></a>字符串相关内容补充</h2><h2 id="字符串常量池在JDK1-7中的变化"><a href="#字符串常量池在JDK1-7中的变化" class="headerlink" title="字符串常量池在JDK1.7中的变化"></a>字符串常量池在JDK1.7中的变化</h2><p>请看下面代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> StringBuilder(<span class="string">"计算机"</span>).append(<span class="string">"软件"</span>).toString();</span><br><span class="line">System.out.println(str1.intern() == str1);</span><br><span class="line"></span><br><span class="line">String str2 = <span class="keyword">new</span> StringBuilder(<span class="string">"ja"</span>).append(<span class="string">"va"</span>).toString();</span><br><span class="line">System.out.println(str2.intern() == str2);</span><br></pre></td></tr></table></figure><p>这段代码在JDK1.6中运行，会得到两个false，而在JDK1.7中运行，会得到一个true和一个false。<br>产生的原因是：在JDK1.6中，intern()方法会把首次遇到的字符串实例复制到永久代中，返回的也是永久代中这个字符串实例的引用，而由StringBuilder创建的字符串实例在Java堆上，所以必然不是同一个引用，将返回false。<br>而JDK1.7(以及其他虚拟机，例如JRockit)的intern()实现不会再复制实例，只是在常量池中记录首次出现的实例引用，因此intern()返回的引用和由StringBuilder创建的那个字符串实例是同一个。对str2比较返回false是因为”java”这个字符串在执行StringBuilder.toString()之前已经出现过，字符串常量池中已经有他的引用了，不符合首次出现的原则，而”计算机软件”这个字符串则是首次出现，因此返回true。</p>]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm详解（三） - 垃圾收集与内存分配策略</title>
    <url>/article/765042407/</url>
    <content><![CDATA[<p>深入探讨垃圾收集与内存分配策略</p><a id="more"></a><h2 id="对象已死吗？"><a href="#对象已死吗？" class="headerlink" title="对象已死吗？"></a>对象已死吗？</h2><p>在堆里面存放着Java中几乎所有的对象实例，垃圾收集器在对堆进行回收之前，第一件事就是要确定这些对象中哪些还存活着，哪些已经死去。</p><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。</p><p>客观的说，引用计数法的实现简单，判定效率也很高，在大部分情况下它都是一个不错的算法。但是至少主流的Java虚拟机里面没有选用引用计数算法来管理内存，其中最主要的原因是他很难解决对象之间相互循环引用的问题。</p><p>举个简单的例子，请看如下代码：对象 <code>objA</code> 和 <code>objB</code> 都有字段 <code>instance</code> ，赋值令 <code>objA.instance = objB</code> 及 <code>objB.instance = objA</code>，除此之外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问，但是因为他们互相引用着对方，导致他们的引用计数器都不为0，因此引用计数算法无法通知GC收集器回收他们。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ReferenceCountingGC objA = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">    ReferenceCountingGC objB = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">    objA.instance = objB;</span><br><span class="line">    objB.instance = objA;</span><br><span class="line">    objA = <span class="keyword">null</span>;</span><br><span class="line">    objB = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>这个算法的基本思路就是通过一系列的称为 <code>GC Roots</code> 的对象作为起始点，从这些节点开始往下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。</p><p>如图所示，对象object5、object6、object7虽然互相有关联，但是他们倒GC Roots是不可达的，所以它们将会被判定为可回收的对象。</p><p><img data-src="/images/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95.png" alt="可达性分析算法判定对象是否可回收"></p><h2 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h2><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与 <code>引用</code> 有关。</p><p>在JDK1.2以前，Java中的引用定义的很传统：如果reference类型的数据中存储的数值代表代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。</p><p>在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为 <code>强引用</code>、 <code>软引用</code>、 <code>弱引用</code>、 <code>虚引用</code> 4种，这4中引用强度依次逐渐减弱。</p><h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p>强引用就是指在代码中普遍存在的， 类似 <code>Object obj = new Object()</code> 这类的引用，只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象。</p><h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>软引用是用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次的回收之后还没有足够的内存，才会抛出内存溢出异常。</p><p>在JDK1.2之后提供了 <code>SoftReference</code> 类来实现软引用。</p><h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>弱引用也是用来描述非必须对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作是，无论当前内存是否足够，都会回收被弱引用关联的对象</p><p>在JDK1.2之后，提供了 <code>WeakReference</code> 类来实现弱引用。</p><h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p>虚引用也称为幽灵引用或幻影引用，他是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个虚引用的实例。</p><p>为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知</p><p>在JDK1.2之后，提供了 <code>PhantomReference</code> 类来实现虚引用。</p><h2 id="不可达对象并非-非死不可-的"><a href="#不可达对象并非-非死不可-的" class="headerlink" title="不可达对象并非 非死不可 的"></a>不可达对象并非 非死不可 的</h2><p>即使在可达性分析算法中不可达的对象，也并非是 <code>非死不可</code> 的，这时候他们暂时处于 <code>缓刑</code> 阶段，要真正宣告一个对象的死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与 <code>GC Roots</code> 相连的引用链，那它将会进行第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 <code>finalize()</code> 方法。<br>当对象没有覆盖 <code>finalize()</code> 方法，或者 <code>finalize()</code> 方法已经被虚拟机调用过，虚拟机将这两种情况都视为 <code>没必要执行</code>。如果这个对象被判定为有必要执行 <code>finalize()</code> 方法，那么这个对象将会放置在一个叫做F-Queue的队列中，并在稍后有一个由虚拟机自己创建的、低优先级的Finalizer线程去执行它。<br>finalize()方法是对象逃脱死亡的最后一次机会，稍后GC将会对F-Queue中的对象进行第二次小规模的标记，如果对象在finalize()方法中成功拯救自己，将会在此次标记中被移除出<code>即将回收</code>的集合，如果对象这时候还没有逃脱，那基本上它就真的被回收了。</p><h2 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h2><p>永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。</p><p>判定一个常量是否是 <code>废弃常量</code> 比较简单，而要判断一个类是否是 <code>无用的类</code> 的条件则相对苛刻许多。类需要同时满足下面3个条件才能算是 <code>无用的类</code>：</p><ul><li>该类所有的实例都已经被回收，也就是Java堆中不存在任何该类的实例。</li><li>加载该类的ClassLoader已经被回收。</li><li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被应用，无法在任何地方通过反射访问该类的方法。</li></ul><p>虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是可以，而并不是和对象一样，不适用了就必然会被回收。是否对类进行回收，HotSpot虚拟机提供了 <code>-Xnoclassgc</code> 参数进行控制。</p><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>算法分为 <code>标记</code> 和 <code>清除</code> 两个阶段： 首先标记处所有需要回收的对象，在标记完成后统一回收所有被标记的对象。</p><p>它是最基础的收集算法，因为后续的收集算法都是基于这种思路并对其不足进行改进而得到的。</p><p>它的不足有两个：一是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p><p><img data-src="/images/%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="标记-清除算法示意图"></p><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>复制算法将可用内存按容量划分为大小相等的两块，每次只是用其中的一块。当这一块的内存用完了，就将还存活的对象复制到另外一块上面，然后再把已使用过的内存空间一次性清理掉。这样使得每次都是对整个半区进行内存回收，内存分配也就不用考虑内存碎片等复杂情况。</p><p>现在的商业虚拟机都采用这种收集算法来回收 <code>新生代</code> ，这种算法将内存分为一块较大的 <code>Eden空间</code> 和两块较小的 <code>Survivor空间</code> ， 每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。<br>HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，当Survivor空间不够用时，对象将直接进入老年代。</p><p>这种算法的优点是实现简单，运行高效。缺点是内存利用率低。</p><p><img data-src="/images/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="复制算法示意图"></p><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>根据老年代的特点提出的一种算法，标记过程仍然与标记-清楚算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><p><img data-src="/images/%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="标记-整理算法示意图"></p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>当前商业虚拟机的垃圾收集都采用 <code>分代收集</code> 算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是将Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。<br>在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对他们进行分配担保，就必须使用 <code>标记-清理</code> 或者 <code>标记-整理</code> 算法来进行回收</p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</p><p>虽然我们是在对各个收集器进行比较，但并非为了挑选出一个最好的收集器。因为直到现在为止还没有最好的收集器出现，更加没有万能的收集器，所以我们选择的只是对具体应用最合适的收集器。这点不需要多加解释就能证明：如果有一种放之四海皆准、任何场景下都适用的完美收集器存在，那么HotSpot虚拟机就没有必要实现那么多不同的收集器了。</p><h3 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h3><p><code>Serial收集器</code> 是最基本、发展历史最悠久的收集器，曾经虚拟机新生代的唯一选择。大家看名字就会知道，这个收集器是一个单线程的收集器，但它的 <code>单线程</code> 的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。<br>这就是我们所说的 <code>Stop The World</code></p><p><img data-src="/images/Serial%E5%92%8CSerialOld%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="Serial/Serial Old收集器运行示意图"></p><p>对于 <code>Stop The World</code> 带给用户的不良影响，虚拟机的设计者们表示完全理解，所以在后续的垃圾收集器设计中停顿时间在不断缩短。</p><p>但是 <code>Serial收集器</code> 也有着优于其他收集器的地方：简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，<code>Serial收集器</code> 由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。</p><p>所以，实际上到现在为止 <code>Serial收集器</code> 依然是虚拟机运行在Client模式下的默认新生代收集器。</p><h3 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h3><p><code>ParNew收集器</code> 其实是 <code>Serial收集器</code> 的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为都与Serial收集器完全一样。</p><p><img data-src="/images/ParNew%E5%92%8CSerialOld%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="ParNew/Serial Old收集器运行示意图"></p><p>它是许多运行在Server模式下的虚拟机的首选的新生代收集器，其中有一个与性能无关但是很重要的原因是，除了Serial收集器外，目前只有它能与CMS收集器配合工作。</p><p><strong>注意</strong>：从ParNew收集器开始，后面还会接触到几款并发和并行的收集器。这里我们先解释一下概念，以免产生疑惑。</p><ul><li>并行（Parallel)：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li><li>并发（Concurrent）：指用户线程和垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行在另一个CPU上。</li></ul><h3 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h3><p><code>Parallel Scavenge收集器</code> 是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器…看上去和ParNew都一样，那它有什么特别之处呢？</p><p><code>Parallel Scavenge收集器</code> 的关注点是吞吐量（吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间))，虚拟机总共运行了100分钟，其中垃圾收集花掉了1分钟，那么吞吐量就是99%。</p><p><code>Parallel Scavenge收集器</code> 提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的 <code>—XX: MaxGCPauseMillis</code> 参数以及直接设置吞吐量大小的 <code>-XX: GCTimeRatio</code> 参数</p><p>如果读者对于收集器运作原理不太了解，手工优化存在困难的时候，使用 <code>Parallel Scavenge收集器</code> 配合自适应调节策略，把内存管理的调优任务交给虚拟机去完成将是一个不错的选择。</p><h3 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h3><p><code>Serial Old收集器</code> 是Serial收集器的老年代版本，它同样是一个单线程收集器，使用 <code>标记-整理</code> 算法。这个收集器的主要意义也是在于给Client模式下的虚拟机使用。<br>如果在Server模式下，那么它主要还有两大用途：</p><ul><li>在JDK1.5以及之前的版本中与 <code>Parallel Scavenge</code> 收集器搭配使用。</li><li>作为CMS收集器的后备预案，在并发收集发生 <code>Concurrent Mode Failure</code> 时使用。</li></ul><p><img data-src="/images/Serial%E5%92%8CSerialOld%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="Serial/SerialOld收集器运行示意图"></p><h3 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h3><p><code>Parallel Old</code> 是 Parallel Scavenge收集器的老年代版本，使用多线程和 <code>标记-整理</code> 算法，在注重吞吐量以及CPU敏感的场合，都可以优先考虑 <code>Parallel Scavenge</code> 加 <code>Parallel Old</code> 收集器。</p><p><img data-src="/images/ParallelScavenge%E5%92%8CParallelOld%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="Parallel Scavenge/Parallel Old收集器运行示意图"></p><h3 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h3><p><code>CMS收集器</code> 是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的互联网网站或者B/S系统的服务端上使用。</p><p>从名字（包含 <code>Mark Sweep</code>) 上就可以看出，CMS是基于 <code>标记-清除</code> 算法实现的，它的运作过程分为4个步骤：</p><ul><li>初始标记：暂停所有其他线程，记录下GC Roots能直接关联到的对象，这一步速度很快。</li><li>并发标记：同时开启用户线程和GC线程，该阶段进行 <code>GC Roots Tracing</code>，就是根据第一步标记出的对象集，遍历出他们关联的所有对象，没有遍历到的对象即为非存活对象。这个阶段结束之后并不能保证包含当前可达的所有对象，因为用户线程可能会不断的更新引用域。</li><li>重新标记：重新标记阶段就是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。</li><li>并发清除：开启用户线程，同时GC线程对未标记的区域做清扫。</li></ul><p><img data-src="/images/ConcurrentMarkSweep%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="Concurrent Mark Sweep 收集器运行示意图"></p><p>CMS 是一款优秀的收集器，他的主要优点是 <code>并发收集</code>、<code>低停顿</code>。但它有一下3个明显的缺点：</p><ul><li>对CPU资源非常敏感：其实，面向并发设计的程序都对CPU资源比较敏感。</li><li>无法处理浮动垃圾：可能出现Concurrent Mode Failure失败而导致另一次 <code>Full GC</code> 的产生。由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，这一部分垃圾就称为 <code>浮动垃圾</code>。因此 <code>CMS收集器</code> 不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。</li><li>产生大量空间碎片：CMS收集器是基于<code>标记-清除</code> 算法实现的收集器，所以每次收集结束时会产生大量的空间碎片。</li></ul><h3 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h3><p><code>G1(Garbage-First)收集器</code> 是当今收集器技术发展的最前沿成果之一。它被视为JDK1.7中HotSpot虚拟机的一个重要进化特征。</p><p>G1是一款面向服务端应用的垃圾收集器。与其他GC收集器相比，G1具备如下特点：</p><ul><li>并行与并发：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短Stop-The-World的停顿时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。</li><li>分代收集：与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。</li><li>空间整合：与CMS的标记-清理算法不同，G1从整体来看是基于 <code>标记-整理</code> 算法实现的收集器，从局部（两个Region之间）上来看是基于 <code>复制</code> 算法来实现的，但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。</li><li>可预测的停顿：G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java的垃圾收集器的特征了。</li></ul><p>在G1之前的其他收集器进行收集的范围都是整个新生代或者老年代，而G1不再是这样。<br>使用G1收集器时，将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留了新生代和老年代的概念，但是新生代和老年代不再是物理隔离的了，他们都是一部分Region（不需要连续）的集合</p><p>G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。<br>G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，有限回收价值最大的Region。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的 <code>回收效率</code>。</p><p>G1收集器的运作大致可划分为以下几个步骤：</p><ul><li>初始标记：标记 GC Roots能直接关联到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象。这阶段需要停顿线程，但耗时很短。</li><li>并发标记：从GC Roots开始对堆中的对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行。</li><li>最终标记：修正在并发标记期间因用户程序正在运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程 <code>Remembered Set Logs</code> 里面，最终标记阶段需要把 <code>Remembered Set Logs</code> 的数据合并到 <code>Remembered Set</code> 中，这阶段需要停顿线程，但是可并行执行</li><li>筛选回收：对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来指定回收计划，这个阶段可以做到与与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率，所以选用了并行执行。</li></ul><p><img data-src="/images/G1%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="G1收集器运行示意图"></p>]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm详解（二） - HotSpot虚拟机对象探秘</title>
    <url>/article/687001131/</url>
    <content><![CDATA[<p>深入探讨HotSpot虚拟机在Java堆中对象分配、布局和访问的全过程</p><a id="more"></a><p>介绍完Java虚拟机的运行时数据区之后，我们大致知道了虚拟机的内存概况，接下来我们进一步了解这些虚拟机内存中的数据的其他细节，譬如它是如何创建、如何布局以及如何访问的。</p><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p><img data-src="/images/Java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B.png" alt="Java对象的创建过程"></p><h3 id="类加载检查"><a href="#类加载检查" class="headerlink" title="类加载检查"></a>类加载检查</h3><p>虚拟机遇到一条new指令时，首先将去检查这条指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p><h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><p>在类加载检查通过后，接下来虚拟机将为新生代对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。<br>分配方式有 <code>指针碰撞</code> 和 <code>空闲列表</code> 两种，使用哪种分配方式是由Java堆中内存是否规整所决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p><p><img data-src="/images/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F.png" alt="内存分配的两种方式"></p><p>内存分配并发问题：<br>除如何划分可用空间外，还有另外一个需要考虑的问题是对象创建在虚拟机是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。<br>解决这个问题有两种方案：</p><ul><li>CAS+失败重试：CAS是乐观锁的一种实现方式，所谓乐观锁就是，每次不加锁而假定不存在冲突而去执行某项操作，如果发生冲突就进行重试，直到成功为止。</li><li>本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）：把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存。哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定，虚拟机是否使用TLAB，可以通过-XX：+/-UseTLAB参数来设定。</li></ul><h3 id="初始化零值"><a href="#初始化零值" class="headerlink" title="初始化零值"></a>初始化零值</h3><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），如果使用TLAB，这一项工作也可以提前到TLAB分配时进行。这一项工作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p><h3 id="设置对象头"><a href="#设置对象头" class="headerlink" title="设置对象头"></a>设置对象头</h3><p>接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header)之中。<br>根据虚拟机当前的运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p><h3 id="执行init方法"><a href="#执行init方法" class="headerlink" title="执行init方法"></a>执行init方法</h3><p>在上面的工作都完成之后，从虚拟机的角度来看，一个新的对象已经产生了，但从Java程序的视角来看，对象创建才刚刚开始，<init>方法还没有执行，所有的字段都还为零。<br>所以，一般来说（由字节码中是否跟随invokespecial指令所决定），执行new指令之后会接着执行 <code>init</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全创建出来。</init></p><h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：<code>对象头</code> 、 <code>实例数据</code> 和 <code>对齐填充</code>。</p><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>HotSpot虚拟机的对象头包含两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。<br>对象头的另外一部分是类型指针，即对象指向它的类元素的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><p>另外，如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据。</p><h3 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h3><p>实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。</p><h3 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h3><p>对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数（1倍或者2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p><h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>建立对象是为了使用对象，我们的Java程序需要通过栈上的reference数据来操作堆上的具体对象。<br>对象的访问方式取决于虚拟机的实现而定的，目前主流的访问方式有使用 <code>句柄</code> 和 <code>直接指针</code> 两种。</p><ul><li>句柄：如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。</li></ul><p><img data-src="/images/%E9%80%9A%E8%BF%87%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png" alt="通过句柄访问对象"></p><ul><li>直接指针：如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址。</li></ul><p><img data-src="/images/%E9%80%9A%E8%BF%87%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png" alt="通过直接指针访问对象"></p><p>这两种访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要修改。<br>使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。HotSpot就是使用直接指针的方式进行对象访问的。</p>]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm详解（四） - 性能监控与故障处理工具</title>
    <url>/article/2177025765/</url>
    <content><![CDATA[<p>介绍虚拟机提供的各种工具的使用方式</p><a id="more"></a><h1 id="JDK命令行工具"><a href="#JDK命令行工具" class="headerlink" title="JDK命令行工具"></a>JDK命令行工具</h1><p>这些命令都存在于JDK的bin目录中：</p><ul><li><code>jps</code>：显示指定系统内所有的HotSpot虚拟机进程。</li><li><code>jstat</code>：用于收集Hotspot虚拟机各方面的运行数据。</li><li><code>jinfo</code>：显示虚拟机配置信息。</li><li><code>jmap</code>：生成虚拟机的内存转储文件（heapdump文件）。</li><li><code>jhat</code>：用于分析heapdump文件，它会建立一个HTTP/HTML服务器，让用户可以在浏览器上查看结果。</li><li><code>jstack</code>：显示虚拟机的线程快照。</li></ul><h2 id="jps：查看所有Java进程"><a href="#jps：查看所有Java进程" class="headerlink" title="jps：查看所有Java进程"></a>jps：查看所有Java进程</h2><p>jps可以列出正在运行的虚拟机进程，并显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一ID。</p><p>jps命令格式： <code>jps [-q] [-mlvV] [&lt;hostid&gt;]</code></p><p><img data-src="/images/jps%E6%89%A7%E8%A1%8C%E6%A0%B7%E4%BE%8B.png" alt="jps执行样例"></p><h2 id="jstat：虚拟机统计信息监视工具"><a href="#jstat：虚拟机统计信息监视工具" class="headerlink" title="jstat：虚拟机统计信息监视工具"></a>jstat：虚拟机统计信息监视工具</h2><p>jstat用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或者远程虚拟机中的类装载、内存、垃圾收集、JIT编译等运行数据，在没有GUI图形界面，只提供了纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的首选工具。</p><p>jstat命令格式：<code>jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]</code></p><p>对于命令格式中的VMID与LVMID需要特别说明一下：如果是本地虚拟机进程，VMID与LVMID是一致的，如果是远程虚拟机进程，那么VMID的格式应当是：<br><code>[protocol: ][//]lvmid[@hostname[:port]/servername]</code></p><p>参数 <code>interval</code> 和 <code>count</code> 代表查询间隔数，如果省略说明只查询一次。</p><p>假如需要每1000毫秒查询一次进程711的垃圾收集状况，一共查询你20次，那命令应当是：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jstat -gc 711 1000 20</span><br></pre></td></tr></table></figure><p>选项 <code>options</code> 代表着用户需要查询的虚拟机信息，主要分为3类：类装载、垃圾收集、运行期编译状况。<br>具体选项和作用如下：</p><ul><li><code>-class</code>：监视类装载、卸载数量、总空间以及类装载所耗费的时间。</li><li><code>-gc</code>：监视Java堆情况，包括Eden区、两个Survivor区、老年代、永久代等的容量、已用空间、GC时间合计等信息。</li><li><code>-gccapacity</code>：监视内容与 <code>-gc</code> 基本相同，但输出主要关注Java堆各个区域使用到的最大、最小空间。</li><li><code>-gcutil</code>：监视内容与 <code>-gc</code> 基本相同，但输出主要关注已使用空间占总空间的百分比。</li><li><code>-gccause</code>：与 <code>-gcutil</code> 功能一样，但是会额外输出导致上一次GC产生的原因。</li><li><code>-gcnew</code>：监视新生代GC状况。</li><li><code>-gcnewcapacity</code>：监视内容与 <code>-gcnew</code> 基本相同，输出主要关注使用到的最大、最小空间。</li><li><code>-gcold</code>：监视老年代GC状况。</li><li><code>-gcoldcapacity</code>：监视内容与 <code>-gcold</code> 基本相同，输出主要关注使用到的最大、最小空间。</li><li><code>-gcpermcapacity</code>：输出永久代使用到的最大、最小空间。</li><li><code>-compiler</code>：输出JIT编译器编译过的方法、耗时等信息。</li><li><code>-printcompilation</code>：输出已经被JIT编译的方法。</li></ul><p><img data-src="/images/jstat%E6%89%A7%E8%A1%8C%E6%A0%B7%E4%BE%8B.png" alt="jstat执行样例"></p><ul><li><code>S0C</code>：新生代 <code>S0区</code> 总空间。</li><li><code>S1C</code>：新生代 <code>S1区</code> 总空间。</li><li><code>S0U</code>：新生代 <code>S0区</code> 已使用空间。</li><li><code>S1U</code>：新生代 <code>S1区</code> 已使用空间。</li><li><code>EC</code>：新生代 <code>Eden区</code> 总空间。</li><li><code>EU</code>: 新生代 <code>Eden区</code> 已使用空间。</li><li><code>OC</code>：老年代总空间。</li><li><code>OU</code>：老年代已使用空间。</li><li><code>MC</code>：方法区总空间。</li><li><code>MU</code>：方法区已使用空间。</li><li><code>CCSC</code>：压缩类总空间。</li><li><code>CCSU</code>：压缩类已使用空间。</li><li><code>YGC</code>：年轻代gc次数</li><li><code>YGCT</code>：年轻代gc总耗时。</li><li><code>FGC</code>：full gc 次数。</li><li><code>FGCT</code>：full gc 总耗时。</li><li><code>GCT</code>：gc总耗时</li></ul><h2 id="jinfo：Java配置信息工具"><a href="#jinfo：Java配置信息工具" class="headerlink" title="jinfo：Java配置信息工具"></a>jinfo：Java配置信息工具</h2><p>jinfo的作用是实时的查看和调整虚拟机各项参数。</p><p>jinfo命令格式：<code>jinfo [option] &lt;pid&gt;</code></p><p><img data-src="/images/%E6%9F%A5%E8%AF%A2CMSInitiatingOccupancyFraction%E5%8F%82%E6%95%B0%E5%80%BC.png" alt="执行样例：查询CMSInitiatingOccupancyFraction参数值"></p><h2 id="jmap：Java内存映射工具"><a href="#jmap：Java内存映射工具" class="headerlink" title="jmap：Java内存映射工具"></a>jmap：Java内存映射工具</h2><p>jmap命令用于生成堆转储快照。<br>jmap的作用并不仅仅是为了获取dump文件，它还可以查询finalize执行队列、Java堆和永久代的信息，如空间使用率、当前用的是那种收集器等。</p><p>jmap命令格式：<code>jmap [option] &lt;pid&gt;</code><br>option选项的合法值与具体含义：</p><ul><li><code>-dump</code>：生成Java堆转储快照。格式为：-dump:[live，]format=b，file=<filename>，其中live子参数说明是否只dump出存活的对象。</filename></li><li><code>-finalizerinfo</code>：显示在 <code>F-Queue</code> 中等待Finalizer线程执行finalize方法的对象。只在Linux/Solaris平台下有效。</li><li><code>-heap</code>：显示Java堆详细信息，如使用哪种回收器、参数配置、分代状况等。只在Linux/Solaris平台下有效。</li><li><code>-histo</code>：显示堆中对象统计信息，包括类、实例数量、合计容量。</li><li><code>-permstat</code>：以ClassLoader为统计口径显示永久代内存状况。只在Linux/Solaris平台下有效</li><li><code>-F</code>：当虚拟机进程对 <code>-dump</code> 选项没有响应时，可使用这个选项强制生成dump快照。只在Linux/Solaris平台下有效。</li></ul><p><img data-src="/images/%E4%BD%BF%E7%94%A8jmap%E7%94%9F%E6%88%90dump%E6%96%87%E4%BB%B6.png" alt="使用jmap生成dump文件"></p><h2 id="jhat：虚拟机堆转储快照分析工具"><a href="#jhat：虚拟机堆转储快照分析工具" class="headerlink" title="jhat：虚拟机堆转储快照分析工具"></a>jhat：虚拟机堆转储快照分析工具</h2><p>JDK提供jhat命令与jmap搭配使用，来分析jmap生成的堆转储文件。jhat内置了一个HTTP/HTML服务器，生成dump文件的分析结果后，可以在浏览器中查看。</p><p>不过在实际工作中jhat很少使用到，平时使用比较多的 <code>VisualVM</code> 将在后面的章节中介绍。</p><h2 id="jstack：Java堆栈跟踪工具"><a href="#jstack：Java堆栈跟踪工具" class="headerlink" title="jstack：Java堆栈跟踪工具"></a>jstack：Java堆栈跟踪工具</h2><p>jstack命令用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间等待的常见原因。</p><p>jtack命令格式：<code>jstack [option] &lt;pid&gt;</code></p><p>option选项的合法值和具体含义：</p><ul><li><code>-F</code>：当正常输出的请求不被响应时，强制输出堆栈。</li><li><code>-l</code>：除堆栈外，显示关于锁的附加信息。</li><li><code>-m</code>：如果调用到本地方法的话，可以显示C/C++的堆栈。</li></ul><p><img data-src="/images/%E4%BD%BF%E7%94%A8jstack%E6%9F%A5%E7%9C%8B%E7%BA%BF%E7%A8%8B%E5%A0%86%E6%A0%88.png" alt="使用jstack查看线程堆栈 (部分结果)"></p><h1 id="JDK的可视化工具"><a href="#JDK的可视化工具" class="headerlink" title="JDK的可视化工具"></a>JDK的可视化工具</h1><p>JDK中除了提供大量的命令行工具外，还有两个功能强大的可视化工具：<code>JConsole</code> 和 <code>VisualVM</code>。</p><h2 id="JConsole：Java监视与管理控制台"><a href="#JConsole：Java监视与管理控制台" class="headerlink" title="JConsole：Java监视与管理控制台"></a>JConsole：Java监视与管理控制台</h2><p>JConsole是一种基于JMX的可视化监控、管理工具</p><h3 id="启动JConsole"><a href="#启动JConsole" class="headerlink" title="启动JConsole"></a>启动JConsole</h3><p>JConsole在启动时将会自动列出本机所有的虚拟机进程，不需要用户自己使用jps命令查询了。</p><p><img data-src="/images/JConsole%E8%BF%9E%E6%8E%A5%E9%A1%B5%E9%9D%A2.png" alt="JConsole连接页面"></p><p>选择虚拟机进程连接之后进入JConsole主界面共包括 <code>概述</code>、<code>内存</code>、<code>线程</code>、<code>类</code>、<code>VM概要</code>、<code>MBean</code> 6个页签。</p><p><img data-src="/images/JConsole%E4%B8%BB%E7%95%8C%E9%9D%A2.png" alt="JConsole主界面"></p><p><code>概述</code> 页签显示的是整个虚拟机主要运行数据的概况，其中包括 <code>堆内存使用量</code>、<code>线程</code>、<code>类</code>、<code>CPU占用率</code> 4种信息的曲线图，这些曲线图是后面<code>内存</code>、<code>线程</code>、<code>类</code> 页签的信息汇总。</p><h3 id="内存监控"><a href="#内存监控" class="headerlink" title="内存监控"></a>内存监控</h3><p><code>内存</code> 页签相当于可视化的jstat命令，用于监视虚拟机的变化趋势。<br>我们通过运行如下代码来体验一下它的监视功能。运行时设置的虚拟机参数为 <code>-Xms100m -Xmx100m -XX:+UseSerialGC</code> 这段代码的作用是以每秒60kb的速度往Java堆中填充数据，一共填充1000次，使用JConsole的内存页签进行监视，观察曲线和柱状指示图的变化。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JConsoleMonitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">byte</span>[] placeHolder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fillHeap</span><span class="params">(<span class="keyword">int</span> num)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		List&lt;JConsoleMonitor&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">			TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">			list.add(<span class="keyword">new</span> JConsoleMonitor());</span><br><span class="line">		&#125;</span><br><span class="line">		System.gc();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		fillHeap(<span class="number">1000</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行后，在 <code>内存</code> 页签中可以看到内存池”Eden Space”区的运行趋势图。</p><p>如图可以发现曲线是一个平滑上升的曲线，并且从柱状图可以看出，在1000次循环执行结束，运行了System.gc()后，虽然新生代Eden和Survivor区都基本被清空了，但是代表老年代的柱状图仍然保持峰值状态，说明被填充进堆中的数据在System.gc()方法执行之后仍然存活。</p><p><img data-src="/images/Edenq%E5%8C%BA%E5%86%85%E5%AD%98%E5%8F%98%E5%8C%96%E6%83%85%E5%86%B5.png" alt="Eden区内存变化情况"></p><p>这里便于我们复习前面学习的知识，我们扩展几个小问题：</p><ul><li>虚拟机启动参数只限制了Java堆为100MB，没有指定-Xmn参数，能否从控制图中估计出新生代有多大？</li><li>为何执行了System.gc()之后，图中代表老年代的柱状图仍然显示峰值状态，代码需要如何调整才能让System.gc()回收掉填充到堆中的对象?</li></ul><p>答案：</p><ul><li>问题一答案：图中显示Eden区空间为27328KB，因为没有设置-XX:SurvivorRadio参数，所以Eden与Survivor空间比例为默认8:1，整个新生代空间大约为27328KB/8*10=34160KB。</li><li>问题二答案：执行完System.gc()之后，空间未能回收是因为List<jconsolemonitor>list对象仍然存活，fillHeap()方法仍然没有退出，因此list对象在System.gc()执行时仍然处于作用域之内，如果把System.gc()移动到fillHeap()方法外调用就可以回收掉全部内存。</jconsolemonitor></li></ul><h3 id="线程监控"><a href="#线程监控" class="headerlink" title="线程监控"></a>线程监控</h3><p>如果上面的”内存”页签相当于可视化的jstat命令的话，”线程”页签的功能就相当于jstack命令，遇到线程停顿时可以使用这个页签进行监控分析。前面讲解jstack命令的时候提到过线程长时间停顿的主要原因有：等待外部资源（数据库连接、网络资源、设备资源等）、死循环、锁等待（活锁和死锁）。<br>通过以下代码分别演示一下这几种情况。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusyThread</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createBusyThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, <span class="string">"testBusyThread"</span>);</span><br><span class="line"></span><br><span class="line">		thread.start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">creatLockThread</span><span class="params">(<span class="keyword">final</span> Object lock)</span> </span>&#123;</span><br><span class="line">		Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						lock.wait();</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, <span class="string">"testLockThread"</span>);</span><br><span class="line">		thread.start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line"></span><br><span class="line">		br.readLine();</span><br><span class="line">		createBusyThread();</span><br><span class="line">		br.readLine();</span><br><span class="line">		Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">		creatLockThread(obj);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行后，首先在”线程”页签中选择main线程，如图所示。堆栈追踪显示BufferedReader在readBytes方法中等待System.in的键盘输入，这时线程为Runnable状态，Runnable状态的线程会被分配运行时间，但readBytes方法检查到流没有更新时会立刻归还执行令牌，这种等待只消耗很小的CPU资源。</p><p><img data-src="/images/main%E7%BA%BF%E7%A8%8B.png" alt="main线程"></p><p>接着监控testBusyThread线程，如图所示，testBusyThread线程一直在执行空循环，从堆栈追踪中看到一直在BusyThread的12行停留，12行为：while(true)。这时候线程为Runnable状态，而且没有归还线程执行令牌的动作，会在空循环上用尽全部执行时间直到线程切换，这种等待会消耗较多的CPU资源。</p><p><img data-src="/images/testBusyThread%E7%BA%BF%E7%A8%8B.png" alt="testBusyThread线程"></p><p>testLockThread线程正处于正常的活锁等待，只要lock对象的notify()或者notifyAll()方法被调用，这个线程便能激活以继续执行。</p><p><img data-src="/images/testLockThread%E7%BA%BF%E7%A8%8B.png" alt="testLockThread线程"></p><p>如下代码演示了一个无法再被激活的死锁等待。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDead</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a, b;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ThreadDead</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.a = a;</span><br><span class="line">		<span class="keyword">this</span>.b = b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (Integer.valueOf(a)) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (Integer.valueOf(b)) &#123;</span><br><span class="line">				System.out.println(a + b);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadDead(<span class="number">1</span>, <span class="number">2</span>)).start();</span><br><span class="line">			<span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadDead(<span class="number">2</span>, <span class="number">1</span>)).start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码开了200个线程去分别计算1+2以及2+1的值，其实for循环是可以省略的，两个线程也可能会导致死锁，不过那样概率太小，需要尝试运行很多次才能看到效果。造成死锁的原因是Integer.valueOf()方法基于减少对象创建次数和节省内存的考虑，[-128, 127]之间的数字会被缓存，当valueOf()方法传入参数在这个范围之内，将直接返回缓存中的对象。也就是说，代码中调用了200次Integer.valueOf()方法一共只返回了两个不同的参数。假如在某个线程的两个synchronized块之间发生了一次线程切换，那就会出现线程A等着被线程B持有的Integer.valueOf(1)，线程B又等着被线程A持有的Integer.valueOf(2)，结果出现大家都跑不下去的情况。</p><p>出现线程死锁之后，点击JConsole线程面板的”检测死锁”按钮，将出现一个新的”死锁”页签，如图所示。</p><p><img data-src="/images/%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81.png" alt="线程死锁"></p><p>图中清晰的显示了线程Thread-145在等待一个被线程Thread-144持有的Integer对象，而点击线程Thread-144则显示它也在等待一个Integer对象，被线程Thread-145持有，这样两个线程就互相卡住，都不存在等到锁释放的希望了。</p><h2 id="VisualVM：多合一故障处理工具"><a href="#VisualVM：多合一故障处理工具" class="headerlink" title="VisualVM：多合一故障处理工具"></a>VisualVM：多合一故障处理工具</h2><p><code>VisualVM</code> 是到目前为止随JDK发布的功能最强大的运行监视和故障处理程序。<br><code>VisualVM</code> 不需要被监视的程序基于特俗Agent运行，因此它对应用程序的实际性能的影响很小，使得它可以直接应用在生产环境中。这个有点是JProfiler、YourKit等工具无法与之媲美的。</p><h3 id="VisualVM兼容范围与插件安装"><a href="#VisualVM兼容范围与插件安装" class="headerlink" title="VisualVM兼容范围与插件安装"></a>VisualVM兼容范围与插件安装</h3><p>安装插件的方式有2种：<br>1.手工安装：在<span class="exturl" data-url="aHR0cHM6Ly92aXN1YWx2bS5naXRodWIuaW8vcGx1Z2luc2NlbnRlcnMuaHRtbA==">相关网站<i class="fa fa-external-link-alt"></i></span>上下载*.nbm包后，点击”工具”-&gt;”插件”-&gt;”已下载”菜单，然后再弹出的对话框中指定nbm包路径便可安装，插件安装后存放在JDK_HOME/lib/visualvm/visualvm中。不过手工安装并不常用，<br>2.自动安装：点击”工具”-&gt;”插件”-&gt;”可用插件”，候选需要安装的插件，点击安装即可。</p><p>注意：<br>如果可用插件列表无法无法显示插件可以在<span class="exturl" data-url="aHR0cHM6Ly92aXN1YWx2bS5naXRodWIuaW8vcGx1Z2luc2NlbnRlcnMuaHRtbA==">相关网站<i class="fa fa-external-link-alt"></i></span>中找到自己使用的VisualVM版本，点击进去之后找到 <code>Catalog URL</code> ，复制url，进入插件页面的设置编辑中的url处，点击确认即可。</p><p><img data-src="/images/VisualVM%E6%8F%92%E4%BB%B6%E9%A1%B5%E7%AD%BE.png" alt="VisualVM插件页签"></p><p><img data-src="/images/VisualVM%E4%B8%BB%E7%95%8C%E9%9D%A2.png" alt="VisualVM主界面"></p><p>VisualVM中”概述”、”监视”、”线程”、”MBeans”的功能与前面介绍的JConsole差别不大。</p><h3 id="生成、浏览堆转储文件"><a href="#生成、浏览堆转储文件" class="headerlink" title="生成、浏览堆转储文件"></a>生成、浏览堆转储文件</h3><p>在VisualVM中生成dump文件有两种方式：</p><ul><li>在”应用程序”窗口中右键单击应用程序结点，然后选择”堆Dump”。</li><li>在”应用程序”窗口中双击应用程序节点以打开应用程序标签，然后再”监视”标签中单击”堆Dump”。</li></ul><p><img data-src="/images/%E6%B5%8F%E8%A7%88Dump%E6%96%87%E4%BB%B6.png" alt="浏览dump文件"></p><h3 id="分析程序性能"><a href="#分析程序性能" class="headerlink" title="分析程序性能"></a>分析程序性能</h3><p>在Profiler页签中，VisualVM提供了程序运行期间方法级的CPU执行时间分析以及内存分析，做Profiling分析肯定会对程序运行性能有比较大的影响，所以一般不在生产环境使用这项功能。</p><p>如果是CPU分析，将会统计每个方法的执行次数、执行耗时；如果是内存分析，则会统计每个方法关联的对象数以及这些对象所占的空间。</p><p>分析结束后，点击”停止”按钮结束监控过程。</p><p><img data-src="/images/%E5%AF%B9%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%BF%9B%E8%A1%8CCPU%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4%E5%88%86%E6%9E%90.png" alt="对应用程序进行CPU执行时间分析"></p><h3 id="BTrace动态日志跟踪"><a href="#BTrace动态日志跟踪" class="headerlink" title="BTrace动态日志跟踪"></a>BTrace动态日志跟踪</h3><p>它的作用是在不停止目标程序运行的前提下，通过HotSpot虚拟机的HotSwap技术动态加入原本并不存在的调试代码。</p><p>在VisualVM中安装了BTrace插件后，在应用程序面板中右键点击要调试的程序，会出现”Trace application…”菜单，点击将进入BTrace面板。</p><p><img data-src="/images/BTrace%E5%8A%A8%E6%80%81%E8%B7%9F%E8%B8%AA.png" alt="BTrace动态跟踪"></p><p>这里有一个简单的Java代码演示BTrace的功能：产生两个1000以内的随机整数，输出这两个数字相加的结果。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BTraceTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a + b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		BTraceTest test = <span class="keyword">new</span> BTraceTest();</span><br><span class="line"></span><br><span class="line">		BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			reader.readLine();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">int</span> a = (<span class="keyword">int</span>) Math.round(Math.random() * <span class="number">1000</span>);</span><br><span class="line">			<span class="keyword">int</span> b = (<span class="keyword">int</span>) Math.round(Math.random() * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">			System.out.println(test.add(a, b));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行后，在VisualVM中打开该程序的监视器，在BTrace页签填充TracingScript的内容。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* BTrace Script Template */</span></span><br><span class="line"><span class="keyword">import</span> com.sun.btrace.annotations.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.sun.btrace.BTraceUtils.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@BTrace</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TracingScript</span> </span>&#123;</span><br><span class="line">	<span class="comment">/* put your code here */</span></span><br><span class="line">    <span class="meta">@OnMethod</span>(clazz=<span class="string">"cn.codeyang.java.BTraceTest"</span>, method=<span class="string">"add"</span>, location=<span class="meta">@Location</span>(Kind.RETURN))</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(@Self cn.codeyang.java.BTraceTest instance, <span class="keyword">int</span> a, <span class="keyword">int</span> b, @Return <span class="keyword">int</span> result)</span> </span>&#123;</span><br><span class="line">        println(<span class="string">"调用堆栈:"</span>);</span><br><span class="line">        jstack();</span><br><span class="line">        println(strcat(<span class="string">"方法参数A:"</span>, str(a)));</span><br><span class="line">        println(strcat(<span class="string">"方法参数B:"</span>, str(b)));</span><br><span class="line">        println(strcat(<span class="string">"方法结果:"</span>, str(result)));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击”Start”按钮后稍等片刻，编译完成后Output面板中将输出一下内容</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">** Compiling the BTrace script ...</span><br><span class="line">*** Compiled</span><br><span class="line">** Instrumenting 1 classes ...</span><br><span class="line">*** Done</span><br><span class="line">** BTrace up&amp;running</span><br><span class="line"></span><br><span class="line">*** Done</span><br><span class="line">** BTrace up&amp;running</span><br></pre></td></tr></table></figure><p>程序运行的时候在Output面板将输出如图所示内容</p><p><img data-src="/images/BTrace%E8%B7%9F%E8%B8%AA%E7%BB%93%E6%9E%9C.png" alt="BTrace跟踪结果"></p>]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm运行原理</title>
    <url>/article/908416262/</url>
    <content><![CDATA[<p>介绍jvm在堆中的运行原理</p><a id="more"></a><h1 id="首先来看一段源码"><a href="#首先来看一段源码" class="headerlink" title="首先来看一段源码"></a>首先来看一段源码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.codeyang.java;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> x = <span class="number">500</span>;</span><br><span class="line">		<span class="keyword">int</span> y = <span class="number">100</span>;</span><br><span class="line">		<span class="keyword">int</span> a = x / y;</span><br><span class="line">		<span class="keyword">int</span> b = <span class="number">50</span>;</span><br><span class="line">		System.out.println(a + b);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用javap反编译"><a href="#使用javap反编译" class="headerlink" title="使用javap反编译"></a>使用javap反编译</h1><p>我们先将这一段代码编译成class文件之后再用下面的命令进行反编译<br><code>javap -v cn.codeyang.java.Demo01</code></p><p>此时我们会在命令行看到如下内容， 这就是我们反编译之后的内容</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Classfile &#x2F;Users&#x2F;yangzhongyang&#x2F;resource&#x2F;git&#x2F;it-study&#x2F;java-study&#x2F;target&#x2F;classes&#x2F;cn&#x2F;codeyang&#x2F;java&#x2F;Demo01.class</span><br><span class="line">  Last modified Nov 4, 2019; size 614 bytes</span><br><span class="line">  MD5 checksum 9efd42a585f9f832df0617ee4bed0847</span><br><span class="line">  Compiled from &quot;Demo01.java&quot;</span><br><span class="line">public class cn.codeyang.java.Demo01</span><br><span class="line">  minor version: 0 &#x2F;&#x2F;次版本号</span><br><span class="line">  major version: 52 &#x2F;&#x2F;主版本号 JDK5、6、7、8分别对应49、50、51、52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER  &#x2F;&#x2F;访问标志</span><br><span class="line">Constant pool:  &#x2F;&#x2F;常量池（区别于字符串常量池），类信息包含的静态常量</span><br><span class="line">   #1 &#x3D; Methodref          #5.#24         &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 &#x3D; Fieldref           #25.#26        &#x2F;&#x2F; java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">   #3 &#x3D; Methodref          #27.#28        &#x2F;&#x2F; java&#x2F;io&#x2F;PrintStream.println:(I)V</span><br><span class="line">   #4 &#x3D; Class              #29            &#x2F;&#x2F; cn&#x2F;codeyang&#x2F;java&#x2F;Demo01</span><br><span class="line">   #5 &#x3D; Class              #30            &#x2F;&#x2F; java&#x2F;lang&#x2F;Object</span><br><span class="line">   #6 &#x3D; Utf8               &lt;init&gt;</span><br><span class="line">   #7 &#x3D; Utf8               ()V</span><br><span class="line">   #8 &#x3D; Utf8               Code</span><br><span class="line">   #9 &#x3D; Utf8               LineNumberTable</span><br><span class="line">  #10 &#x3D; Utf8               LocalVariableTable</span><br><span class="line">  #11 &#x3D; Utf8               this</span><br><span class="line">  #12 &#x3D; Utf8               Lcn&#x2F;codeyang&#x2F;java&#x2F;Demo01;</span><br><span class="line">  #13 &#x3D; Utf8               main</span><br><span class="line">  #14 &#x3D; Utf8               ([Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">  #15 &#x3D; Utf8               args</span><br><span class="line">  #16 &#x3D; Utf8               [Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">  #17 &#x3D; Utf8               x</span><br><span class="line">  #18 &#x3D; Utf8               I</span><br><span class="line">  #19 &#x3D; Utf8               y</span><br><span class="line">  #20 &#x3D; Utf8               a</span><br><span class="line">  #21 &#x3D; Utf8               b</span><br><span class="line">  #22 &#x3D; Utf8               SourceFile</span><br><span class="line">  #23 &#x3D; Utf8               Demo01.java</span><br><span class="line">  #24 &#x3D; NameAndType        #6:#7          &#x2F;&#x2F; &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #25 &#x3D; Class              #31            &#x2F;&#x2F; java&#x2F;lang&#x2F;System</span><br><span class="line">  #26 &#x3D; NameAndType        #32:#33        &#x2F;&#x2F; out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">  #27 &#x3D; Class              #34            &#x2F;&#x2F; java&#x2F;io&#x2F;PrintStream</span><br><span class="line">  #28 &#x3D; NameAndType        #35:#36        &#x2F;&#x2F; println:(I)V</span><br><span class="line">  #29 &#x3D; Utf8               cn&#x2F;codeyang&#x2F;java&#x2F;Demo01</span><br><span class="line">  #30 &#x3D; Utf8               java&#x2F;lang&#x2F;Object</span><br><span class="line">  #31 &#x3D; Utf8               java&#x2F;lang&#x2F;System</span><br><span class="line">  #32 &#x3D; Utf8               out</span><br><span class="line">  #33 &#x3D; Utf8               Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">  #34 &#x3D; Utf8               java&#x2F;io&#x2F;PrintStream</span><br><span class="line">  #35 &#x3D; Utf8               println</span><br><span class="line">  #36 &#x3D; Utf8               (I)V</span><br><span class="line">&#123;</span><br><span class="line">  public cn.codeyang.java.Demo01(); &#x2F;&#x2F; 构造方法</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC &#x2F;&#x2F; 构造函数的访问类型 public类型， 具体含义请看访问标志部分</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;1, locals&#x3D;1, args_size&#x3D;1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lcn&#x2F;codeyang&#x2F;java&#x2F;Demo01;</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);  &#x2F;&#x2F;main函数</span><br><span class="line">    descriptor: ([Ljava&#x2F;lang&#x2F;String;)V  </span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC  &#x2F;&#x2F;main方法的访问控制  public static</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;3, locals&#x3D;5, args_size&#x3D;1  &#x2F;&#x2F; 本地变量5个， 方法参数1个， 方法对应操作数栈中栈帧的深度为3</span><br><span class="line">         0: sipush        500  &#x2F;&#x2F; main方法具体的指令码</span><br><span class="line">         3: istore_1</span><br><span class="line">         4: bipush        100</span><br><span class="line">         6: istore_2</span><br><span class="line">         7: iload_1</span><br><span class="line">         8: iload_2</span><br><span class="line">         9: idiv</span><br><span class="line">        10: istore_3</span><br><span class="line">        11: bipush        50</span><br><span class="line">        13: istore        4</span><br><span class="line">        15: getstatic     #2                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">        18: iload_3</span><br><span class="line">        19: iload         4</span><br><span class="line">        21: iadd</span><br><span class="line">        22: invokevirtual #3                  &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(I)V</span><br><span class="line">        25: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 5: 0</span><br><span class="line">        line 6: 4</span><br><span class="line">        line 7: 7</span><br><span class="line">        line 8: 11</span><br><span class="line">        line 9: 15</span><br><span class="line">        line 10: 25</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      26     0  args   [Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">            4      22     1     x   I</span><br><span class="line">            7      19     2     y   I</span><br><span class="line">           11      15     3     a   I</span><br><span class="line">           15      11     4     b   I</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;Demo01.java&quot;</span><br></pre></td></tr></table></figure><h2 id="访问标志如下"><a href="#访问标志如下" class="headerlink" title="访问标志如下"></a>访问标志如下</h2><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>是否为public类型</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>是否被声明为final,只有类可以设置</td></tr><tr><td>ACC_SUPER</td><td>0x0020</td><td>是否允许使用invokespecial字节码指令,jdk1.2之后编译出来的类的这个标志为true</td></tr><tr><td>ACC_INTERFACE</td><td>0x0200</td><td>标志这个是一个接口</td></tr><tr><td>ACC_ABSTRACT</td><td>0x0400</td><td>是否为abstract类型，对于接口或抽象类来说，此标志值为true，其他值为false</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>标志这个类并非由用户产生的</td></tr><tr><td>ACC_ANNOTATION</td><td>0x2000</td><td>标志这是一个注解</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>标志这是一个枚举</td></tr></tbody></table><h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><table><thead><tr><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>CONSTANT_utf8_info</td><td>UTF-8编码的字符串</td></tr><tr><td>CONSTANT_integer_info</td><td>整形字面量</td></tr><tr><td>CONSTANT_Float_info</td><td>浮点型字面量</td></tr><tr><td>CONSTANT_Long_info</td><td>长整形字面量</td></tr><tr><td>CONSTANT_Double_info</td><td>双精度浮点型字面量</td></tr><tr><td>CONSTANT_Class_info</td><td>类或接口的符号引用</td></tr><tr><td>CONSTANT_String_info</td><td>字符串类型的字面量</td></tr><tr><td>CONSTANT_Fieldref_info</td><td>字段的符号引用</td></tr><tr><td>CONSTANT_Methodref_info</td><td>类中方法的符号引用</td></tr><tr><td>CONSTANT_InterfaceMethodref_info</td><td>接口中方法的符号引用</td></tr><tr><td>CONSTANT_NameAndType_info</td><td>字段或方法的符号引用</td></tr><tr><td>CONSTANT_MethodType_info</td><td>标志方法类型</td></tr><tr><td>CONSTANT_MethodHandle_info</td><td>表示方法句柄</td></tr><tr><td>CONSTANT_InvokeDynamic_info</td><td>表示一个动态方法调用点</td></tr></tbody></table><h1 id="main方法分析"><a href="#main方法分析" class="headerlink" title="main方法分析"></a>main方法分析</h1><p>main方法在栈中的具体执行流程如下<br><img data-src="/images/jvm%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86.gif" alt="main方法的执行流程"></p>]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>打造个性化博客</title>
    <url>/article/3001274396/</url>
    <content><![CDATA[<h1 id="集成utteranc插件"><a href="#集成utteranc插件" class="headerlink" title="集成utteranc插件"></a>集成utteranc插件</h1><p><code>npm install theme-next/hexo-next-utteranc</code></p>]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>解决SpringBoot项目打包后无法获取到项目文件的问题</title>
    <url>/article/4141211754/</url>
    <content><![CDATA[<p>解决实际SpringBoot项目中打包后无法正常获取到文件流的问题</p><a id="more"></a><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>实际项目开发过程中可能无法遇到这个问题, 但是项目发布测试环境之后SpringBoot会被打成jar包, 并以jar包的形式发布运行,这时候之前获取文件流的代码就会报 <code>FileNotFoundException</code></p><h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream signatureStream = <span class="keyword">this</span>.getClass().getClassLoader().getResourceAsStream(<span class="string">"file/text.txt"</span>);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode(148) 排序链表</title>
    <url>/article/104416296/</url>
    <content><![CDATA[<p>本章介绍对链表的归并排序, 要求时间复杂度为 <code>O(n log n)</code> 和常量级空间复杂度</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: 4-&gt;2-&gt;1-&gt;3</span><br><span class="line">输出: 1-&gt;2-&gt;3-&gt;4</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: -1-&gt;5-&gt;3-&gt;4-&gt;0</span><br><span class="line">输出: -1-&gt;0-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路一-归并排序-递归法"><a href="#思路一-归并排序-递归法" class="headerlink" title="思路一: 归并排序 - 递归法"></a>思路一: 归并排序 - 递归法</h3><p>通过递归实现列表的归并查询, 主要分为以下几个步骤</p><ul><li>查找链表的中点, 并将链表从中点断开</li><li>将断开的两个链表合并排序</li></ul><p><img data-src="/images/sort-list-node-1.png" alt="递归法-归并排序"></p><h3 id="思路二-归并排序-循环法"><a href="#思路二-归并排序-循环法" class="headerlink" title="思路二: 归并排序 - 循环法"></a>思路二: 归并排序 - 循环法</h3><p>想要通过循环进行归并排序的话需要进行如下步骤</p><ul><li>定义一个变量 <code>intv</code> 表示每次归并排序需要操作的链表长度, 每次归并排序之后 <code>intv</code> 需要乘以 <code>2</code> , 当 <code>intv</code> &gt;= 链表长度的时候表示归并排序完成</li><li>同时我们需要定义几个变量<ul><li><code>len</code> 表示链表长度</li><li><code>intv</code> 表示当前归并项的长度</li><li><code>res</code> 用来连接链表头, 方便排序后找到链表头</li><li><code>preTail</code> 表示上一次归并排序之后的链表尾结点, 方便当前归并排序之后将切割的链表重新连接回去</li><li><code>h1</code> , <code>h2</code> 表示归并项</li><li><code>tail</code> 表示当前归并项归并排序之后的链表尾结点, 用来将归并操作时切割出来的链表重新组装回去</li><li><code>tailH1</code> , <code>tailH2</code> 用来切割当前归并项</li><li><code>nextH1</code> , <code>nextH2</code> 下一次循环需要使用到的 <code>h1</code> , <code>h2</code></li></ul></li></ul><p><img data-src="/images/sort-list-node-2.png" alt="循环法-归并排序"></p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><h3 id="递归方式"><a href="#递归方式" class="headerlink" title="递归方式"></a>递归方式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取链表的中间节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ListNode <span class="title">getMiddle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode fast = head;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并两个链表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">merge</span><span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head1 == <span class="keyword">null</span> &amp;&amp; head2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (head1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (head2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode head = <span class="keyword">null</span>;</span><br><span class="line">    ListNode cur1 = <span class="keyword">null</span>;</span><br><span class="line">    ListNode cur2 = <span class="keyword">null</span>;</span><br><span class="line">    ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">    ListNode next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (head1.val &lt;= head2.val) &#123;</span><br><span class="line">        head = head1;</span><br><span class="line">        cur1 = head1;</span><br><span class="line">        cur2 = head2;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        head = head2;</span><br><span class="line">        cur1 = head2;</span><br><span class="line">        cur2 = head1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cur1 != <span class="keyword">null</span> &amp;&amp; cur2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur1.val &lt;= cur2.val) &#123;</span><br><span class="line">            pre = cur1;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pre.next = cur2;</span><br><span class="line">            next = cur2.next;</span><br><span class="line">            cur2.next = cur1;</span><br><span class="line">            pre = cur2;</span><br><span class="line">            cur2 = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cur1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        pre.next = cur2;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pre.next = cur1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 时间复杂度 nLogn</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode middleNode = getMiddle(head);</span><br><span class="line">    ListNode right = middleNode.next;</span><br><span class="line">    middleNode.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    ListNode mergedNode = merge(sort(head), sort(right));</span><br><span class="line">    <span class="keyword">return</span> mergedNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        len++;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">getStep</span><span class="params">(ListNode head, <span class="keyword">int</span> step)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (step &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">        step--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取链表的尾结点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">getTail</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (head.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环方式"><a href="#循环方式" class="headerlink" title="循环方式"></a>循环方式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并两个链表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">merge</span><span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head1 == <span class="keyword">null</span> &amp;&amp; head2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (head1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (head2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode head = <span class="keyword">null</span>;</span><br><span class="line">    ListNode cur1 = <span class="keyword">null</span>;</span><br><span class="line">    ListNode cur2 = <span class="keyword">null</span>;</span><br><span class="line">    ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">    ListNode next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (head1.val &lt;= head2.val) &#123;</span><br><span class="line">        head = head1;</span><br><span class="line">        cur1 = head1;</span><br><span class="line">        cur2 = head2;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        head = head2;</span><br><span class="line">        cur1 = head2;</span><br><span class="line">        cur2 = head1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cur1 != <span class="keyword">null</span> &amp;&amp; cur2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur1.val &lt;= cur2.val) &#123;</span><br><span class="line">            pre = cur1;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pre.next = cur2;</span><br><span class="line">            next = cur2.next;</span><br><span class="line">            cur2.next = cur1;</span><br><span class="line">            pre = cur2;</span><br><span class="line">            cur2 = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cur1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        pre.next = cur2;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pre.next = cur1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        len++;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">getStep</span><span class="params">(ListNode head, <span class="keyword">int</span> step)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (step &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">        step--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取链表的尾结点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">getTail</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (head.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1: 获取链表长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> len = getLength(head);</span><br><span class="line">    <span class="keyword">int</span> intv = <span class="number">1</span>;</span><br><span class="line">    ListNode res = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    res.next = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (intv &lt; len) &#123;</span><br><span class="line">        ListNode preTail = res;</span><br><span class="line">        ListNode h1 = preTail.next;</span><br><span class="line">        ListNode h2 = getStep(preTail.next, intv);</span><br><span class="line">        ListNode tail = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (h1 != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            ListNode nextH1 = getStep(h2, intv);</span><br><span class="line">            ListNode nextH2 = getStep(nextH1, intv);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 截断h1和h2</span></span><br><span class="line">            ListNode tailH1 = getStep(h1, intv-<span class="number">1</span>);</span><br><span class="line">            ListNode tailH2 = getStep(h2, intv - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (tailH1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                tailH1.next = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tailH2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                tailH2.next = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            ListNode mergedNode = merge(h1, h2);</span><br><span class="line">            preTail.next = mergedNode;</span><br><span class="line">            tail = getTail(mergedNode);</span><br><span class="line">            tail.next = nextH1;</span><br><span class="line">            preTail = tail;</span><br><span class="line"></span><br><span class="line">            h1 = nextH1;</span><br><span class="line">            h2 = nextH2;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        intv = intv * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
</search>
